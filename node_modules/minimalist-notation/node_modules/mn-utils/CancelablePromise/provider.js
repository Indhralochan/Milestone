const create = require('../create');
const delay = require('../delay');
const defer = require('../defer');
const eachApply = require('../eachApply');
const executeTry = require('../executeTry');
const isObject = require('../isObject');
const isFunction = require('../isFunction');
const isPromise = require('../isPromise');
const isArray = require('../isArray');
const forEach = require('../forEach');
const map = require('../map');
const getter = require('../get/getter');


module.exports = function(ctx) {
  ctx = ctx || {};
  const deferApply = ctx.defer || defer;
  const ParentClass = ctx.ParentClass;

  function CancelablePromise(executor) {
    const self = this;
    let pool = [];
    let args;
    let applied;
    let cancelInner = cancelNoop;
    let cancelResolve = cancelNoop;
    function normalizeWrap(onResolve) {
      return (subject) => {
        if (applied) return cancelNoop;
        applied = 1;
        cancelResolve = deferApply(() => {
          isPromise(subject)
            ? (cancelResolve
                = subject.then(onResolve, reject).cancel || cancelNoop)
            : onResolve(subject);
        });
        return () => {
          cancelResolve();
        };
      };
    }
    function resolve(_subject, hasError) {
      args || (
        args = [_subject, hasError],
        eachApply(pool),
        pool = 0,
        cancelResolve = cancelInner = cancelNoop
      );
    }
    function reject(_subject) {
      if (pool.length < 1) {
        self._hasErrorHandle
          || console.error('Unhandled promise rejection:', _subject);
      }
      resolve(_subject, 1);
    }

    function cancelInit() {
      if (!args) {
        args = [new Error('Already canceled'), 1];
        executeTry(cancelResolve, null, null, onErrorCancel);
        executeTry(cancelInner, null, null, onErrorCancel);
        cancelResolve = cancelInner = cancelNoop;
      }
      pool = 0;
    }

    const _resolve = self.resolve = normalizeWrap(resolve);
    const _reject = self.reject = normalizeWrap(reject);
    const init = subscribleInit(() => {
      function setCancel(_cancel) {
        isFunction(_cancel) && (cancelInner = _cancel);
      }
      let cancel;
      if (executor) {
        if (!isFunction(executor)) {
          throw new Error('Executor param must be a function');
        }
        try {
          cancel = executor(_resolve, _reject);
          isPromise(cancel)
            ? setCancel(cancel.then(setCancel).cancel)
            : setCancel(cancel);
        } catch (ex) {
          _reject(ex);
        }
      }
      return cancelInit;
    }, _reject);
    self.cancel = init();

    function __chain(onResolve, onReject) {
      let stop;
      function handle() {
        stop || (args[1] ? onReject : onResolve)(args[0]);
      }
      if (args) return deferApply(handle);
      pool.push(handle);

      const cancel = init();
      return () => {
        stop = 1;
        cancel();
      };
    }
    function __then(onResolve, onReject, onCancel) {
      if (onCancel && !isFunction(onCancel)) {
        throw new Error('onCancel param must be a function');
      }

      onResolve = getter(onResolve);
      if (onResolve && !isFunction(onResolve)) {
        throw new Error('onResolve param must be a function');
      }

      onReject = getter(onReject);
      if (onReject && !isFunction(onReject)) {
        throw new Error('onReject param must be a function');
      }

      return new CancelablePromise((__resolve, __reject) => {
        const cancel = __chain(
          onResolve ? (subject) => {
            try {
              __resolve(onResolve(subject));
            } catch (ex) {
              __reject(ex);
            }
          } : __resolve,
          onReject ? (error) => {
            try {
              __resolve(onReject(error));
            } catch (ex) {
              __reject(ex);
            }
          } : __reject,
        );
        return onCancel ? () => {
          cancel();
          onCancel();
        } : cancel;
      });
    }
    self.then = __then;
    self.catch = (onReject, onCancel) => __then(null, onReject, onCancel);
    self.finally = (onFinally) => {
      if (!isFunction(onFinally)) {
        throw new Error('The argument can only be a function');
      }
      const promise = __then(
          (subject) => {
            executeTry(onFinally, [null, subject], null, onErrorFinally);
            return subject;
          },
          (subject) => {
            executeTry(onFinally, [subject], null, onErrorFinally);
            throw subject;
          },
          () => {
            executeTry(onFinally, [null, null, true], null, onErrorFinally);
          },
      );
      promise._hasErrorHandle = 1;
      return promise;
    };
    self.onCancel = (onCancel) => __then(null, null, onCancel);
  }

  CancelablePromise.resolve = (subject) => {
    return new CancelablePromise((resolve) => {
      resolve(subject);
    });
  };
  CancelablePromise.reject = (subject) => {
    return new CancelablePromise((resolve, reject) => {
      reject(subject);
    });
  };
  CancelablePromise.all = (promises) => {
    return new CancelablePromise((resolve, reject) => {
      if (!isObject(promises)) {
        throw new TypeError('argument may only be an Object: ' + promises);
      }
      function clear() {
        stop = 1;
        forEach(pendingPromises, cancelPromise);
      }
      function onReject(subject) {
        if (stop) return;
        clear();
        reject(subject);
      }
      function setValue(key, value) {
        output[key] = value;
        ++loaded < length || resolve(output);
      }
      function step(value, key) {
        isPromise(value)
          ? pendingPromises.push(value.then(
              (value) => setValue(key, value),
              onReject,
          ))
          : setValue(key, value);
      }
      const pendingPromises = [];
      let stop;
      let output;
      let loaded = 0;
      let length = 1;
      let k;
      if (isArray(promises)) {
        output = new Array(length = promises.length);
        forEach(promises, step);
      } else {
        output = {};
        for (k in promises) { // eslint-disable-line
          length++;
          step(promises[k], k);
        }
        length--;
      }
      loaded < length || resolve(output);
      return clear;
    });
  };
  CancelablePromise.race = (promises) => {
    return new CancelablePromise((resolve, reject) => {
      if (!isObject(promises)) {
        throw new TypeError('argument may only be an Object: ' + promises);
      }
      function clear() {
        stop = 1;
        forEach(pendingPromises, cancelPromise);
      }
      function onResolve(subject) {
        if (stop) return;
        clear();
        resolve(subject);
      }
      function setError(key, error) {
        errors[key] = error;
        ++loaded < length || reject(errors);
      }
      function step(value, key) {
        isPromise(value)
          ? (stop
            ? cancelPromise(value)
            : pendingPromises.push(value.then(
                onResolve,
                (error) => setError(key, error),
            ))
          )
          : stop || onResolve(value);
      }
      const pendingPromises = [];
      let stop;
      let errors;
      let loaded = 0;
      let length = 1;
      let k;
      if (isArray(promises)) {
        errors = new Array(length = promises.length);
        forEach(promises, step);
      } else {
        errors = {};
        for (k in promises) { // eslint-disable-line
          length++;
          step(promises[k], k);
        }
        length--;
      }
      loaded < length || reject(errors);
      return clear;
    });
  };
  CancelablePromise.delay = (fn, _delay, subject) => {
    return new CancelablePromise((resolve) => {
      return isFunction(fn) ? delay(() => {
        resolve(fn(subject));
      }, _delay) : delay(resolve, fn, [_delay]);
    });
  };
  CancelablePromise.provide = (executor) => {
    return new CancelablePromise(executor);
  };
  CancelablePromise.defer = (fn, subject) => {
    return new CancelablePromise((resolve) => deferApply(() => {
      resolve(isFunction(fn) ? fn(subject) : fn);
    }));
  };
  CancelablePromise.promisify = (fn) => {
    return function() {
      const self = this, args = map(arguments, null, []); // eslint-disable-line
      return new CancelablePromise((resolve, reject) => {
        args.push((error, result) => {
          error
            ? reject(error)
            : resolve(result);
        });
        return fn.apply(self, args);
      });
    };
  };
  CancelablePromise.promisifyStream = (stream, onReadable) => {
    return new CancelablePromise((resolve, reject) => {
      stream.on('end', resolve);
      stream.on('error', reject);
      stream.on('readable', () => {
        onReadable(_read);
      });
      function _read() {
        return stream.read();
      }
      return () => {
        stream.destroy();
      };
    });
  };

  ParentClass && (CancelablePromise.prototype = create(ParentClass.prototype));

  return CancelablePromise;
};
function onErrorCancel(error) {
  console.error('An error occurred in the "cancel" callback:', error);
}
function onErrorFinally(error) {
  console.error('An error occurred in the "finally" callback:', error);
}
function cancelNoop() {
  return false;
}
function cancelPromise(promise) {
  promise.cancel && promise.cancel();
}
function subscribleInit(init) {
  let count = -1;
  let cancel = init();
  return () => {
    count++;
    // cancel || (cancel = init());
    return () => {
      if (!cancel) return false;
      if (--count < 1) {
        cancel();
        cancel = null;
      }
      return true;
    };
  };
}
